# AUTOGENERATED! DO NOT EDIT! File to edit: carmen.ipynb.

# %% auto 0
__all__ = ['OPENAI_API_KEY', 'model', 'GAME_STATE_FILE', 'MAX_HOPS', 'python_repl', 'tools', 'get_game_states',
           'store_game_state', 'get_game_state', 'generate_new_game', 'new_game', 'fetch_game_state',
           'set_current_city', 'update_game_state', 'generate_destinations', 'generate_regular_clues',
           'generate_mistaken_clues', 'generate_arrest_clues', 'get_agent_executor', 'get_destinations', 'get_clues',
           'travel']

# %% carmen.ipynb 2
import os
from langchain_openai import ChatOpenAI
import json

from retrying import retry

from langchain_core.tools import tool
from langchain.agents import Tool
from langchain_experimental.utilities import PythonREPL

from langchain_core.prompts import ChatPromptTemplate
from langchain.agents import create_tool_calling_agent
from langchain.agents import AgentExecutor

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
model = "gpt-4"

GAME_STATE_FILE = "./carmen_game_state.json"
MAX_HOPS = 5

# %% carmen.ipynb 3
def get_game_states():
    if not os.path.exists(GAME_STATE_FILE):
        return {}
    
    with open(GAME_STATE_FILE, "r") as f:
        return json.load(f)

# %% carmen.ipynb 4
def store_game_state(game_state: dict):
    game_states = get_game_states()
    game_states[game_state["case_id"]] = game_state

    with open(GAME_STATE_FILE, "w") as f:
        json.dump(game_states, f)

# %% carmen.ipynb 5
def get_game_state(case_id: str):
    return get_game_states()[case_id]

# %% carmen.ipynb 10
def generate_new_game():
    new_game_prompt = f"""
    System: You are the game master for a detective game like "where in the world is Carmen San Diego". 
    To start the game, generate the following and return it as a json hash. 
    1. A random uuid, key: case_id
    2. A suspect name: suspect_name
    3. A source city, key: current_city 
    4. A famous artifact from that city, key: stolen_item
    5. A list of {MAX_HOPS + 1} unique cities with the current city as the first element, key: hops
    6. Set a field called next_hop to 1
    
    Make the suspect name and artifacts as campy as possible but use real city names. 

    Here is an example:
    {{
        case_id: <uuid>,
        suspect_name: <suspect_name>,
        current_city: <current_city>,
        stolen_item: <item name>,
        hops: [
            <city 1>,
            <city 2>,
            <city 3>,
            <city 4>,
            <city 5>,
            <city 6>,
        ],
        next_hop: 1
    }}
    
    Output only the json hash. Do not provide any other text output. 
    """
    llm = ChatOpenAI(api_key=OPENAI_API_KEY, model=model)

    return llm.invoke(new_game_prompt).content
    

# %% carmen.ipynb 12
@retry(stop_max_delay=15000, stop_max_attempt_number=3)
def new_game():
    game_state = json.loads(generate_new_game())
    store_game_state(game_state)

    res_fields = ["case_id", "suspect_name", "current_city", "stolen_item"]
    res = {}

    for field in res_fields:
        res[field] = game_state[field]
        
    return res

# %% carmen.ipynb 16
@tool
def fetch_game_state(case_id: str) -> str:
    """ Fetch the game state given the case_id """
    return json.dumps(get_game_states()[case_id])

# %% carmen.ipynb 18
@tool
def set_current_city(case_id: str, current_city: str):
    """ Sets the current city for the given case_id """
    game_state = get_game_state(case_id)
    game_state["current_city"] = current_city

    store_game_state(game_state)
    

# %% carmen.ipynb 20
@tool
def update_game_state(case_id, key, value):
    """ Updates the game state based on the values given """
    game_state = get_game_state(case_id)
    game_state[key] = value

    store_game_state(game_state)

# %% carmen.ipynb 22
@tool
def generate_destinations(previous_city: str, next_city: str, current_city: str, exclude_list: str) -> str:
    """ Generates destinations for the player to travel to given the current city, previous city, 
    the next city, and a list of cities to exclude """
    llm = ChatOpenAI(api_key=OPENAI_API_KEY, model=model)

    prompt = f"""
        Generate a list of 4 cities. The list must include {previous_city}, {next_city} 
        and 2 other cities. It must not include {current_city} or any of the
        cities in {exclude_list}. Then shuffle the list before returning it. 
        
        Return this as a json list named destinations. Do not include any additional text.

        Here is an example of the json format:
        destinations: [
            <city 1>,
            <city 2>,
            <city 3>,
            <city 4>,
        ]
        """

    return llm.invoke(prompt).content

# %% carmen.ipynb 24
@tool
def generate_regular_clues(city: str) -> str:
    """ Generate regular clues given a location """
    prompt = f"""
        Generate 3 clues. To generate each clue, do the following 
        1. Pick 3 locations at random out of bank, embassy, restaurant, tour guide, library. 
        2. Generate a clue for each of the locations
        
        The clue for a bank should be the currency of the country. For example if the city is London, 
        the clue should say "The suspect changed their currency to Pounds"
        
        The clue for the embassy should be about the flag of the country. For example, if the city is 
        New York, the clue should say "The suspect enquired about visiting a country with a red, white, and blue flag"
        
        The clue for the restaurant should be a good from the country the city is in. For example, for Mumbai, the clue
        should say "The suspect was looking for fresh samosas"
        
        The clue for tour guide should be something about a famous tourist attraction from the city. For example, for 
        Lima the clue should say "The suspect was interested in exploring Incan ruins"
        
        The clue for the library should be about a famous author from the country the city is in. For example, for London
        the clue could say "The suspect was interested in visiting the grave of Charles Dickens"
        
        Return it as a json hash with the following keys as a response:
        1. clues: a list of json hashes with keys location and clue
        
        Here is an example of the output json format:
        "clues": [
            {{
                "location": <location 1>,
                "clue": <clue 1>,
            }},
            {{
                "location": <location 2>,
                "clue": <clue 2>,
            }},
            {{
                "location": <location 3>,
                "clue": <clue 3>,
            }},
        ]
        
        Do not generate any additional text.
       
        Now generate clues for {city}
    """
    return ChatOpenAI(api_key=OPENAI_API_KEY, model=model).invoke(prompt).content

# %% carmen.ipynb 26
@tool
def generate_mistaken_clues() -> str:
    """ Generate mistaken clues """
    prompt = f"""
        Generate 3 clues. To generate each clue, do the following 
        1. Pick 3 locations at random out of bank, embassy, restaurant, tour guide, library. 
        2. Set the clue to "No one with the suspect's description was seen here"
        
        Return it as a json hash with the following keys as a response:
            a. clues: a list of json hashes with keys location and clue

        Here is an example of the output json format:
        "clues": [
            {{
                "location": <location 1>,
                "clue": <clue 1>,
            }},
            {{
                "location": <location 2>,
                "clue": <clue 2>,
            }},
            {{
                "location": <location 3>,
                "clue": <clue 3>,
            }},
        ]
                
        Do not generate any additional text.

        Now generate the clues
    """
    return ChatOpenAI(api_key=OPENAI_API_KEY, model=model).invoke(prompt).content

# %% carmen.ipynb 28
@tool
def generate_arrest_clues(suspect_name: str) -> str:
    """ Generate arrest clues given the name of the suspect"""
    prompt = f"""
        Generate 3 clues. To generate each clue, do the following 
        1. Pick 3 locations at random out of bank, embassy, restaurant, tour guide, library. 
        2. For two of them set the clue to "Watch your step. You are getting close"
        3. For the third, set the clue to "Congratulations! You have arrested the suspect, {suspect_name}
        
        Return it as a json hash with the following keys as a response:
            a. clues: a list of json hashes with keys location and clue

        Here is an example of the output json format:
        "clues": [
            {{
                "location": <location 1>,
                "clue": <clue 1>,
            }},
            {{
                "location": <location 2>,
                "clue": <clue 2>,
            }},
            {{
                "location": <location 3>,
                "clue": <clue 3>,
            }},
        ]
 
        Do not generate any additional text.

        Now generate the clues for {suspect_name} 
    """
    return ChatOpenAI(api_key=OPENAI_API_KEY, model=model).invoke(prompt).content

# %% carmen.ipynb 30
python_repl = Tool(
    name="python_repl",
    description="A Python shell. Use this to execute python commands. Input should be a valid python command. If you want to see the output of a value, you should print it out with `print(...)`.",
    func=PythonREPL().run,
)

# %% carmen.ipynb 31
tools = [
    fetch_game_state, 
    generate_destinations, 
    generate_regular_clues, 
    generate_arrest_clues, 
    generate_mistaken_clues,
    python_repl,
    update_game_state,   
]

# %% carmen.ipynb 32
def get_agent_executor():
    prompt = ChatPromptTemplate.from_messages(
        [
          ("system", "You are the game master for a detective game like 'where in the world is Carmen San Diego'. You will have to make a lot of decisions so look at the clues carefully."),
          ("placeholder", "{chat_history}"),
          ("human", "{input}"),
          ("placeholder", "{agent_scratchpad}"),
        ]
    )

    llm = ChatOpenAI(api_key=OPENAI_API_KEY, model=model)
    # Construct the tool calling agent
    agent = create_tool_calling_agent(llm, tools, prompt)

    # Create an agent executor by passing in the agent and tools
    agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

    return agent_executor

# %% carmen.ipynb 33
@retry(stop_max_delay=15000, stop_max_attempt_number=3)
def get_destinations(case_id):
    agent_executor = get_agent_executor()
    
    prompt = f"""
    Do the following:
    1. Fetch the game state for case_id {case_id}
    2. Write python code passing in the game state to do the following:
        a. Extract the current_city from the game state obtained above
        b. Get the city at the index next_hop from the hops list in the game state and save it as the next city
        c. If next_hop is 1 then set the previous city to "" otherwise get the city at the index next_hop -1 from 
            the hops list in the game state and save it as the previous city
        d. Add all other cities in the hops list to an exclude list
    
    3. Based on the output above, generate 4 destinations for the player to travel to including the previous city,
    current city, next city, and cities not in the exclude list. 
    4. Shuffle the list
    
    Return the output as a json hash with the following keys:
    1. city: The current city
    2. destinations: a list of the cities

    Here is an example of the output format:
    {{
        "city": <current city>
        "destinations": [
            <city 1>,
            <city 2>,
            <city 3>,
            <city 4>,
        ]
    }}
            
    Generate no additional text 
    """
    ret = agent_executor.invoke(
        {
            "input": prompt
        }
    )

    return json.loads(ret['output'])

# %% carmen.ipynb 35
@retry(stop_max_delay=15000, stop_max_attempt_number=3)
def get_clues(case_id):
    agent_executor = get_agent_executor()
    
    prompt = f"""
    1. Fetch the game state for case_id {case_id}.
    2. Write and execute python code passing in the game state to do the following to figure out what kind of 
       clue to generate:
        a. Extract next_hop from the game state
        b. If next_hop is equal to {MAX_HOPS + 1} only then print "arrest clues" as the type of clues
        c. Else If the current city is not in the hops list only then print "mistaken clues" as the type of clue
        d. Else print "regular clues" as the type of clue
    3. Based on the output of the code generate the right type of clue for the city at index next_hop in the hops list
    
    Return the output exactly as a hash encoded in json returned from the tool. Generate no additional text
    """
    ret = agent_executor.invoke(
        {
            "input": prompt
        }
    )

    return json.loads(ret['output'])

# %% carmen.ipynb 39
@retry(stop_max_delay=15000, stop_max_attempt_number=3)
def travel(case_id, city):
    agent_executor = get_agent_executor()
    
    prompt = f"""
        1. Fetch the game state for case_id {case_id}
        2. Write python code passing in the game state to do the following:
            a. If {city} is not in the hops list, update current_city to {city} and print out the 
            new values of current_city and next_hop as a json hash
            b. Else if {city} is in the hops list and the index of {city} is <= next_hop then 
            set next_hop to the index + 1 and current_city to {city}. Print out the 
            new values of current_city and next_hop as a json hash
            c. Else if {city} is in hops list and the index of {city} is greater than next_hop 
            print the error "Error: You cannot travel to that city"

        If there is no error from the python code, 
        1. Update the current_city and next_hop in the game state
        2. return the current city as json hash with a current_city key. 
        
        Else if there is an error from the python code, return the error "You cannot travel to that city" as a 
        json hash with the key "error".
        
        Here is an example of the output format when there is no error:
        {{
            "current_city": <city>
        }}

        Here is an example of the output format when there is an error:
        {{
            "error": "You cannot travel to that city"
        }}

        Generate no additional text.

    """

    ret = agent_executor.invoke(
        {
            "input": prompt
        }
    )

    return json.loads(ret['output'])
    
